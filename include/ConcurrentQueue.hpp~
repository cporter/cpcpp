
#ifndef __CONCURRENT_QUEUE_HPP__
#define __CONCURRENT_QUEUE_HPP__

#include <boost/thread.hpp>

template <typename T>
class ConcurrentQueue {
private:
  std::queue<T> q;
  mutable boost::mutex mutex;
  boost::condition_variable cond;
  
public:
  void Enqueue(T t);
  T Dequeue();
  const size_t Count() const;
};

template<typename T>
void ConcurrentQueue<T>::Enqueue(T t)
{ boost::mutex::scoped_lock lock(mutex);
  q . push(t);
  lock . unlock();
  cond . notify_one();
}

template<typename T>
T ConcurrentQueue<T>::Dequeue()
{ boost::mutex::scoped_lock lock(mutex); 
  while( 0 == q . size() )
    cond . wait (lock);
  T tmp = q . front();
  q . pop();
  return tmp;
}

template<typename T>
const size_t ConcurrentQueue<T>::Count() const
{ boost::mutex::scoped_lock lock(mutex);
  return q . size();
}



#endif //!__CONCURRENT_QUEUE_HPP__
